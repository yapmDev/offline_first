# Understanding `resolvedPayload`

## What is `resolvedPayload`?

`resolvedPayload` is a field in `SyncResult` that allows your `RemoteAdapter` to return updated entity data from the server back to the local storage after a successful sync operation.

## Why is it needed?

When you sync an operation with the server, the server often modifies or adds fields to your entity:

- **Version fields** for optimistic locking (incremented on each update)
- **Timestamps** (createdAt, updatedAt) generated by the server
- **Auto-generated IDs** or UUIDs
- **Computed fields** (e.g., fullName from firstName + lastName)
- **Normalized data** (server's canonical representation)

Without `resolvedPayload`, your local entity would be out of sync with the server, causing issues on subsequent operations.

## How does it work?

### Flow Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. User updates product (name: "Widget", version: 0)           │
│    → Repository saves to Hive                                   │
│    → OfflineStore.logUpdate() registers operation              │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. User triggers sync                                           │
│    → SyncEngine processes pending operations                    │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. RemoteAdapter.update() sends to server                      │
│    PUT /api/products/123                                        │
│    { "name": "Widget", "version": 0 }                          │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. Server validates version, updates, increments                │
│    ← 200 OK                                                     │
│    { "id": "123", "name": "Widget", "version": 1,              │
│      "updatedAt": "2026-01-25T10:30:00Z" }                     │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 5. RemoteAdapter returns SyncResult with resolvedPayload       │
│    SyncResult.success(                                          │
│      resolvedPayload: {                                         │
│        "id": "123",                                             │
│        "name": "Widget",                                        │
│        "version": 1,  ← NEW VERSION FROM SERVER                │
│        "updatedAt": "2026-01-25T10:30:00Z"                     │
│      }                                                          │
│    )                                                            │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 6. SyncEngine receives result                                   │
│    if (result.resolvedPayload != null) {                       │
│      await _storage.saveEntity(                                │
│        'product', '123', result.resolvedPayload               │
│      );                                                         │
│    }                                                            │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 7. StorageAdapter.saveEntity() updates Hive                    │
│    productBox.put('123', ProductModel.fromJson(data))          │
│    → Hive now has version: 1 ✅                                │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│ 8. SyncEngine marks operation as synced                        │
│    → Operation removed from log                                 │
│    → UI shows "0 pending operations"                           │
└─────────────────────────────────────────────────────────────────┘
```

## Implementation Example

### RemoteAdapter

```dart
@injectable
class ProductRemoteAdapter implements RemoteAdapter<ProductModel> {
  final DioClient _dioClient;
  
  ProductRemoteAdapter(this._dioClient);
  
  @override
  String get entityType => 'product';
  
  @override
  Future<SyncResult> create(Operation operation) async {
    final response = await _dioClient.dio.post(
      '/api/products',
      data: operation.payload,
      options: Options(
        headers: {'X-Operation-Id': operation.operationId},
      ),
    );
    
    if (response.statusCode == 201) {
      final data = response.data as Map<String, dynamic>;
      
      // ✅ Build complete payload with server data
      final resolvedPayload = {
        'id': data['id'],
        'name': data['name'],
        'price': data['price'],
        'version': data['version'],        // From server
        'schemaVersion': data['schemaVersion'],
        'createdAt': data['createdAt'],
        'updatedAt': data['updatedAt'],
      };
      
      return SyncResult.success(
        serverId: data['id'],
        serverTimestamp: DateTime.parse(data['updatedAt']).millisecondsSinceEpoch,
        resolvedPayload: resolvedPayload,  // ← KEY: This updates Hive
      );
    }
    
    // Handle errors...
  }
  
  @override
  Future<SyncResult> update(Operation operation) async {
    final version = operation.payload['version'];
    
    final response = await _dioClient.dio.put(
      '/api/products/${operation.entityId}',
      data: {
        ...operation.payload,
        'version': version,  // Current version for optimistic locking
      },
      options: Options(
        headers: {'X-Operation-Id': operation.operationId},
      ),
    );
    
    if (response.statusCode == 200) {
      final data = response.data as Map<String, dynamic>;
      
      // ✅ Update with new version from server
      final resolvedPayload = {
        'id': data['id'],
        'name': data['name'],
        'price': data['price'],
        'version': data['version'],        // Incremented by server
        'updatedAt': data['updatedAt'],
      };
      
      return SyncResult.success(
        serverTimestamp: DateTime.parse(data['updatedAt']).millisecondsSinceEpoch,
        resolvedPayload: resolvedPayload,  // ← KEY: Updates version in Hive
      );
    } else if (response.statusCode == 409) {
      // Version conflict
      return SyncResult.conflict(conflictData: response.data);
    }
    
    // Handle other errors...
  }
}
```

### StorageAdapter

Your `StorageAdapter` must implement `saveEntity()` to handle the update:

```dart
@singleton
class HiveStorageAdapter implements StorageAdapter {
  late Box<ProductModel> _productBox;
  
  @override
  Future<void> initialize() async {
    _productBox = await Hive.openBox<ProductModel>('products');
    // ... other boxes
  }
  
  @override
  Future<void> saveEntity(
    String entityType,
    String entityId,
    Map<String, dynamic> data,
  ) async {
    // Called by SyncEngine after successful sync
    switch (entityType) {
      case 'product':
        final model = ProductModel.fromJson(data);
        await _productBox.put(entityId, model);
        break;
      // ... other entity types
    }
  }
  
  // ... other methods
}
```

## Common Mistakes

### ❌ Not returning `resolvedPayload`

```dart
// BAD: Server data is lost
if (response.statusCode == 200) {
  return SyncResult.success();  // version not updated in Hive
}
```

### ❌ Returning incomplete payload

```dart
// BAD: Only version, missing other fields
if (response.statusCode == 200) {
  final data = response.data;
  return SyncResult.success(
    resolvedPayload: {
      'version': data['version'],  // Missing id, name, price, etc.
    },
  );
}
```

### ❌ StorageAdapter throws `UnsupportedError`

```dart
// BAD: SyncEngine can't update entity
@override
Future<void> saveEntity(...) async {
  throw UnsupportedError('Not implemented');
}
```

### ✅ Correct implementation

```dart
// GOOD: Complete payload with all fields
if (response.statusCode == 200) {
  final data = response.data;
  
  final resolvedPayload = {
    'id': data['id'],
    'name': data['name'],
    'price': data['price'],
    'version': data['version'],        // Server-managed
    'schemaVersion': data['schemaVersion'],
    'createdAt': data['createdAt'],
    'updatedAt': data['updatedAt'],
  };
  
  return SyncResult.success(
    resolvedPayload: resolvedPayload,
  );
}
```

## When to use `resolvedPayload`

| Scenario | Use `resolvedPayload`? | Why |
|----------|------------------------|-----|
| Optimistic locking (version fields) | ✅ Yes | Version must be synced with server |
| Server-generated timestamps | ✅ Yes | Keep timestamps accurate |
| Auto-increment IDs | ✅ Yes | Server assigns final ID |
| Computed fields | ✅ Yes | Server calculates canonical value |
| Simple CRUD (no server changes) | ⚠️ Optional | Not strictly needed but good practice |
| Delete operations | ❌ No | Entity is deleted, nothing to update |

## Best Practices

1. **Always return complete entity**: Include all fields in `resolvedPayload`, not just changed ones
2. **Parse server response carefully**: Ensure field names match your model
3. **Handle null values**: Use fallbacks in `fromJson()` methods
4. **Test sync flow**: Verify version increments correctly after sync
5. **Implement `saveEntity()`**: Don't throw `UnsupportedError` if you need server data sync
6. **Log for debugging**: Add logging to track version changes

## Troubleshooting

### Problem: "Version is required for update" error

**Cause:** The `version` field is not in the payload sent to the server.

**Solution:** Ensure your model stores `version` and includes it in `toJson()`:

```dart
Map<String, dynamic> toJson() => {
  'id': id,
  'name': name,
  'version': version,  // ← Must include
};
```

### Problem: Operations stay "pending" after sync

**Cause:** `StorageAdapter.saveEntity()` throws an error or is not implemented.

**Solution:** Implement `saveEntity()` properly:

```dart
@override
Future<void> saveEntity(String entityType, String entityId, Map<String, dynamic> data) async {
  switch (entityType) {
    case 'product':
      final model = ProductModel.fromJson(data);
      await productBox.put(entityId, model);
      break;
    default:
      throw UnsupportedError('Unknown entity type: $entityType');
  }
}
```

### Problem: Version conflicts on every update

**Cause:** Local version is not being updated after sync.

**Solution:** Ensure `resolvedPayload` includes the new version and `saveEntity()` is called:

1. Check RemoteAdapter returns `resolvedPayload` with new version
2. Check `StorageAdapter.saveEntity()` is implemented
3. Check `ProductModel.fromJson()` correctly parses version
4. Add logging to verify version updates

## See Also

- [USAGE_MODES.md](USAGE_MODES.md) - Hybrid Mode documentation
- [ADVANCED_USAGE.md](ADVANCED_USAGE.md) - Optimistic Locking section
- [ARCHITECTURE.md](ARCHITECTURE.md) - Sync Engine internals
